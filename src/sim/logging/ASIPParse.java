package sim.logging;

import java.util.*;
import java.util.regex.*;
import java.io.*;

import sim.network.assembly.RealTopology;
import sim.network.dataObjects.AS;

/**
 * This object does the construction of a weighting metric for our fake prefixes
 * that give us an idea of how many actual IP blocks would be advertised. This
 * is generated by looking at a dump of a route views routing table, checking
 * which ASes we actually use in our topology, and pruning up when we find ASes
 * that we don't use.
 * 
 */
public class ASIPParse {

	/**
	 * CIDR (in str form) to set of hosting ASes mapping
	 */
	private HashMap<String, HashSet<Integer>> blockToASMapping;

	/**
	 * Mapping between ASN to the IP weight
	 */
	private HashMap<Integer, Integer> simASToBlockCount;

	/**
	 * Stores the copy of the ASN to AS object map (needed for some uses outside
	 * of normal sim runs)
	 */
	private HashMap<Integer, AS> asMap;

	private static final Pattern PREFIX = Pattern
			.compile("PREFIX: ([0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+)");
	private static final Pattern ASPATH = Pattern.compile("ASPATH: (.+)");
	private static final Pattern ASREL = Pattern
			.compile("([0-9]+) ([0-9]+) ([0-9])");

	private static final String ASREL_FILE = "conf/as_rel.txt";
	public static final String RIB_FILE = "routeViews/readable.txt";

	/**
	 * Builds a mapping of ASNs to ip block weighting. At the end of this
	 * constructor you're good to call the getter, fetch the table, and call it
	 * a day w/ this object.
	 * 
	 * @param fileName
	 *            - the human readable dump from a route views RIB
	 * @throws IOException
	 *             - errors opening key files needed to build this will throw
	 *             one of these
	 */
	public ASIPParse(String fileName) throws IOException {
		this.blockToASMapping = new HashMap<String, HashSet<Integer>>();
		this.simASToBlockCount = new HashMap<Integer, Integer>();

		/*
		 * Opens up the route views RIP dump first
		 */
		BufferedReader fBuff = new BufferedReader(new FileReader(fileName));
		String currPrefix = null;

		String poll = null;
		Matcher prefMatch = null;
		Matcher pathMatch = null;

		System.out.println("Starting RIB parse for ASN weighting");
		while (fBuff.ready()) {
			poll = fBuff.readLine();

			/*
			 * Check to see if this line is an IP block prefix, if so, set the
			 * current prefix equal to it, and look at the next line
			 */
			prefMatch = ASIPParse.PREFIX.matcher(poll);
			if (prefMatch.find()) {
				currPrefix = prefMatch.group(1);
				continue;
			}

			/*
			 * If we have a current prefix we're working on, check if this line
			 * is a path, if we don't have a prefix yet, then ignore the line
			 */
			if (currPrefix != null) {
				pathMatch = ASIPParse.ASPATH.matcher(poll);

				/*
				 * If we find an AS path, tokenize it, grab the last hop, which
				 * will be the owning AS
				 */
				if (pathMatch.find()) {
					StringTokenizer tokens = new StringTokenizer(pathMatch
							.group(1), " ");
					String lastHop = tokens.nextToken();
					while (tokens.hasMoreTokens()) {
						lastHop = tokens.nextToken();
					}

					/*
					 * Trim the added data about sib ASes, and aliases
					 */
					lastHop = lastHop.trim().replaceAll("\\{", "").replaceAll(
							"\\}", "");
					if (lastHop.contains(",")) {
						lastHop = lastHop.substring(0, lastHop.indexOf(","));
					}

					/*
					 * Turn it into an ASN, add it to the set of ASes that "own"
					 * the given IP block
					 */
					int tAS = (int)Long.parseLong(lastHop); //!!!! I changed Int.parseInt to Long.parseLong dueto the large lastHop
					if (!this.blockToASMapping.containsKey(currPrefix)) {
						this.blockToASMapping.put(currPrefix,
								new HashSet<Integer>());
					}
					this.blockToASMapping.get(currPrefix).add(tAS);

					/*
					 * Since we've now given a path to the CIDR, remove that
					 * CIDR from consideration
					 */
					currPrefix = null;
				}
			}
		}

		/*
		 * Done with the RIB dump
		 */
		fBuff.close();
		System.out.println("Done with parsing RIB dump");

		/*
		 * TODO at some point it would be really nice to try and aggregate IP
		 * blocks where we can, this will more then likely have to be done on a
		 * per-ASN basis
		 */

		/*
		 * Generate the ASN => AS object map
		 */
		RealTopology tempRTopoBuilder = new RealTopology(ASIPParse.ASREL_FILE,
				true, "OC3", "OC48", "OC192", "OC768");
		this.asMap = tempRTopoBuilder.getASMap();
		System.out.println("used as count: " + this.asMap.size());
		HashMap<Integer, HashSet<Integer>> uphillASMap = new HashMap<Integer, HashSet<Integer>>();

		/*
		 * Load the full AS relationship database into memory, so we can build
		 * the directed BGP graph, just keep the "uphill" side, since that's all
		 * we need
		 */
		BufferedReader asRelBuff = new BufferedReader(new FileReader(
				ASIPParse.ASREL_FILE));
		Matcher relMatcher = null;
		while (asRelBuff.ready()) {
			poll = asRelBuff.readLine();
			relMatcher = ASIPParse.ASREL.matcher(poll);

			if (relMatcher.find()) {
				if (Integer.parseInt(relMatcher.group(3)) != 1) {
					int lhs = Integer.parseInt(relMatcher.group(1));
					int rhs = Integer.parseInt(relMatcher.group(2));

					if (!uphillASMap.containsKey(lhs)) {
						uphillASMap.put(lhs, new HashSet<Integer>());
					}
					uphillASMap.get(lhs).add(rhs);
				}
			}
		}
		asRelBuff.close();

		/*
		 * For each IP block, step through, figure out if all owning ASes are
		 * credited, if the owning ASes don't exist in our topo then credit it
		 * to their uphill ASes, continue checking to make sure that the uphill
		 * ASes exist
		 */
		HashSet<Integer> poss = new HashSet<Integer>();
		HashSet<Integer> next = new HashSet<Integer>();
		HashSet<Integer> done = new HashSet<Integer>();
		for (String tIP : this.blockToASMapping.keySet()) {
			poss.clear();
			next.clear();
			done.clear();

			poss.addAll(this.blockToASMapping.get(tIP));
			while (poss.size() > 0) {
				next.clear();

				for (int tAS : poss) {
					done.add(tAS);

					if (this.asMap.containsKey(tAS)) {
						if (this.simASToBlockCount.containsKey(tAS)) {
							this.simASToBlockCount.put(tAS,
									this.simASToBlockCount.get(tAS) + 1);
						} else {
							this.simASToBlockCount.put(tAS, 1);
						}
					} else {
						HashSet<Integer> nextASes = uphillASMap.get(tAS);
						if (nextASes != null) {
							for (Integer tNextAS : nextASes) {
								if ((!next.contains(tNextAS))
										&& (!done.contains(tNextAS))
										&& (!poss.contains(tNextAS))) {
									next.add(tNextAS);
								}
							}
						}
					}
				}

				poss.clear();
				poss.addAll(next);
			}
		}
	}

	public HashMap<Integer, AS> getASMap() {
		return this.asMap;
	}

	public int multiOwnerCount() {
		int count = 0;

		for (String tIP : this.blockToASMapping.keySet()) {
			if (this.blockToASMapping.get(tIP).size() > 1) {
				count++;
			}
		}

		return count;
	}

	/**
	 * Gets the number of CIDRs seen in the routing table dump. This does not do
	 * anything smart when one CIDR is contained inside another.
	 * 
	 * @return - the number of unique CIDRs seen.
	 */
	public int getIPSpace() {
		return this.blockToASMapping.size();
	}

	/**
	 * Gets the ASN weighting we've built.
	 * 
	 * @return a hash map of ASNs mapping to number of CIDRs seen
	 */
	public HashMap<Integer, Integer> getASWeighting() {
		return this.simASToBlockCount;
	}

	public static void main(String[] args) throws IOException {
		ASIPParse obj = new ASIPParse(ASIPParse.RIB_FILE);
		System.out.println("multi owner: " + obj.multiOwnerCount());
		System.out.println("size is: " + obj.getIPSpace());

		HashMap<Integer, Integer> theData = obj.getASWeighting();
		System.out.println("sim to AS size is: " + theData.size());
		int sum = 0;
		List<Integer> medianList = new ArrayList<Integer>(theData.size());
		for (int tAS : theData.keySet()) {
			medianList.add(theData.get(tAS));
			sum += theData.get(tAS);
		}
		Collections.sort(medianList);

		int med = -1;
		if (medianList.size() % 2 == 0) {
			med = (medianList.get(medianList.size() / 2 - 1) + medianList
					.get(medianList.size() / 2)) / 2;
		} else {
			med = medianList.get(medianList.size() / 2);
		}

		System.out.println("avg is: " + (double) sum / (double) theData.size());
		System.out.println("median is: " + med);
	}

}
